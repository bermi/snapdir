#!/usr/bin/env bash

# # snapdir
#
# Create, audit and distribute authenticated directory snapshots.
#
# ## Usage
#
#     snapdir [OPTIONS] [SUBCOMMAND] [ARGUMENTS]
#
# ### Options
#
#     --cache-dir=DIR        Directory where the object cache is stored.
#     --debug                Enable debug output.
#     --dryrun               Run without making any changes.
#     --force                Force an action to run.
#     --help, -h             Prints help message.
#     --id=ID                Manifest ID to use.
#     --keep                 Keeps the staging directory.
#     --linked               Use symlinks instead of copies.
#     --path=PATH            Partial path for checkout operations.
#     --purge                Purges objects with invalid checksums.
#     --store=URI            Store URI protocol://location/path.
#     --verbose              Enable verbose output.
#     --version, -v          Prints version.
#
# ### Commands
#
#
#     checkout --id= [--linked] DIR  Checkout a snapshot to a directory.
#     defaults                       Prints default settings and arguments.
#     fetch --id= --store=           Fetch a snapshot from a store.
#     flush-cache                    Flushes the local cache.
#     help [COMMAND]                 Prints help information.
#     id [PATH]                      Prints the manifest ID of a directory
#                                    or manifest provided via stdin.
#     manifest PATH                  Prints the manifest of a directory.
#     pull --id= --store= PATH       Fetches a snapshot from a store and checks
#                                    it out the given path.
#     push --store= [--id=] [PATH]   Pushes a snapshot to a store given its path or
#                                    a staged manifest ID.
#     stage DIR                      Saves into the local cache a snapshot of
#                                    a directory.
#     test                           Runs unit tests for snapdir.
#     verify --id= [--purge]         Verifies the integrity of a staged snapshot.
#     verify-cache [--purge]         Verifies the integrity of the local cache.
#     version                        Prints the version.
#
# ### Arguments
#
#     <DIR>    Directory path for snapshot operations.
#     <PATH>   Path to an object in a manifest to cherry-pick.
#
# ### Environment variables
#
#     SNAPDIR_MANIFEST_CONTEXT    Context string for deriving key in keyed mode.
#                                 This only works with b3sum.
#     SNAPDIR_MANIFEST_EXCLUDE    Default grep -v rule for --exclude="system".
#
# ### Examples
#
#     # generates a manifest for the current directory
#     snapdir manifest ./
#
#     # generates an id for the manifest of the current directory
#     snapdir id ./
#
#     # excludes files and directories matching the pattern
#     snapdir --exclude="/(.git|.DS_Store)($|/)" manifest ./
#
#     # stages a snapshot of the current directory
#     snapdir stage ./
#
#     # verifies a snapshot given its id, to purge invalid objects add --purge
#     snapdir verify --verbose --id=d640dce8e26f39d4dae336a7da83478385ce52a844c1d9b91f204ef83c558dd2
#
#     # checks out a copy of the snapshot on a given directory
#     snapdir checkout --id=d640dce8e26f39d4dae336a7da83478385ce52a844c1d9b91f204ef83c558dd2 ./two
#
#     # use --linked if you prefer to create a hard link and use a COW filesystem
#     snapdir checkout --link --id=d640dce8e26f39d4dae336a7da83478385ce52a844c1d9b91f204ef83c558dd2 ./two
#
# LICENSE: MIT Copyright (c) 2022 Bermi Ferrer

# By default this script will take the name of the current file
_SNAPDIR="snapdir"
if [[ ${BASH_SOURCE[0]} == "$0" ]]; then
	_SNAPDIR="$(basename "${BASH_SOURCE[0]}")"
fi
_SNAPDIR_VERSION="0.3.1"

set -eEuo pipefail
IFS=$'\n\t'

#     #    #    #     # ### ####### #######  #####  #######
##   ##   # #   ##    #  #  #       #       #     #    #
# # # #  #   #  # #   #  #  #       #       #          #
#  #  # #     # #  #  #  #  #####   #####    #####     #
#     # ####### #   # #  #  #       #             #    #
#     # #     # #    ##  #  #       #       #     #    #
#     # #     # #     # ### #       #######  #####     #

snapdir_manifest() {
	# Prints on the stdout a manifest for a directory or staged manifest ID.
	#
	# Usage:
	#
	#     snapdir manifest \
	#         [--(id="${MANIFEST_ID}")] \
	#         [--(exclude="${EXCLUDE_PATTERN}")] \
	#         [--stage] \
	#         "${DIR}"
	#
	# Returns: [A snapdir manifest](docs/understanding-manifests.md) as
	#          a UTF-8 encoded string.
	#
	# Examples:
	#
	#     # generates a manifest for a directory
	#     snapdir manifest "${DIR}"
	#
	#     # generates a manifest for a directory and stages it
	#     # creating a copy of the objects in the local cache
	#     snapdir manifest --stage "${DIR}"
	#
	#     # excludes files matching the pattern
	#     snapdir manifest --exclude ".ignore" "${DIR}"
	#
	#			# exclude commonly ignored files, such as .git and .DS_Store
	#			snapdir manifest --exclude "%common%" "${DIR}"
	#
	#     # excludes files matching the pattern while
	#     # keeping the default common pattern
	#     snapdir manifest --exclude ".ignore|%common%" "${DIR}"
	#
	#     # use a custom secret for b3sum context
	#     SNAPDIR_MANIFEST_CONTEXT="${SECRET}" snapdir manifest "${DIR}"
	#
	#     # reads the directory from stdin
	#      echo "${DIR}" | snapdir manifest
	#
	#     # shows the manifest for an staged manifest ID
	#     snapdir manifest --id "${MANIFEST_ID}"
	#
	#     # shows the manifest given a staged manifest ID trhough stdin
	#     echo "${MANIFEST_ID}" | snapdir manifest
	#
	set -eEuo pipefail
	# the manifest only gets generated once per call
	if [[ ${_SNAPDIR_MANIFEST:-} != "" ]]; then
		echo "$_SNAPDIR_MANIFEST"
		return 0
	fi
	# Returns a list of files and the directories that should be part of the snapshot in the following format
	# <file_path> <b3sum|-> <mode>
	local base_dir
	base_dir="$(_snapdir_get_base_dir "${1:-""}")"
	local snapdir_dir_abs_path
	snapdir_dir_abs_path="$(realpath "${base_dir}")"
	local verbose_flag=""
	if [[ ${_SNAPDIR_VERBOSE:-false} == "true" ]]; then
		verbose_flag="--verbose"
	fi
	if [[ ${snapdir_dir_abs_path%/} == "/" ]]; then
		# shellcheck disable=SC2086
		_SNAPDIR_MANIFEST=$("${_SNAPDIR_BIN_DIR}/snapdir-manifest" $verbose_flag --cache --exclude="${_SNAPDIR_EXCLUDE:-system}" "/")
	else
		test -d "${snapdir_dir_abs_path}" || {
			echo "error: Snapshot directory '${snapdir_dir_abs_path}' does not exist." >&2
			return 1
		}
		if [[ ${_SNAPDIR_EXCLUDE} != "" ]]; then
			_snapdir_log "Running: ${_SNAPDIR_BIN_DIR}/snapdir-manifest $verbose_flag --cache --exclude=\"${_SNAPDIR_EXCLUDE}\" \"$snapdir_dir_abs_path\""
			# shellcheck disable=SC2086
			_SNAPDIR_MANIFEST=$("${_SNAPDIR_BIN_DIR}/snapdir-manifest" $verbose_flag --cache --exclude="${_SNAPDIR_EXCLUDE}" "$snapdir_dir_abs_path")
		else
			_snapdir_log "Running: ${_SNAPDIR_BIN_DIR}/snapdir-manifest $verbose_flag --cache \"$snapdir_dir_abs_path\""
			# shellcheck disable=SC2086
			_SNAPDIR_MANIFEST=$("${_SNAPDIR_BIN_DIR}/snapdir-manifest" $verbose_flag --cache "$snapdir_dir_abs_path")
		fi

	fi
	if [[ ${_SNAPDIR_STAGE:-false} == "true" ]]; then
		_snapdir_log "Staging manifest: ${_SNAPDIR_MANIFEST}"
		snapdir_stage "${1:-""}" >/dev/null
	fi

	echo "${_SNAPDIR_MANIFEST}"
}

#       ### ######
#        #  #     #
#        #  #     #
#        #  #     #
#        #  #     #
#        #  #     #
#       ### ######

snapdir_id() {
	# Generates a snapshot id for a given directory and writes it to stdout.
	#
	# Usage:
	#
	#     snapdir id [--stage] "${DIR}"
	#
	# Returns: Snapshot ID (a BLAKE3 hash for the manifest contents)
	#
	# Examples:
	#
	#     # generates a snapshot id for a directory
	#     snapdir id "${DIR}"
	#
	#     # generates a snapshot id for a directory and stages
	#     # the contents and the manifest id in the local cache
	#     snapdir manifest --stage "${DIR}"
	#
	#     # generates a snapshot id for a manifest provided as stdin
	#     echo "${DIR}" | snapdir manifest | snapdir id
	#
	set -eEuo pipefail
	# the id only gets generated once per call
	if [[ ${_SNAPDIR_ID:-} != "" ]]; then
		echo "$_SNAPDIR_ID"
		return 0
	fi
	local manifest="${_SNAPDIR_MANIFEST:-""}"
	if [[ ${manifest} == "" ]]; then
		local base_dir
		base_dir="$(_snapdir_get_base_dir "${1:-""}")"
		manifest="$(snapdir_manifest "${base_dir}")"
	fi
	_SNAPDIR_ID="$(echo "$manifest" | grep -v "^#" | b3sum --no-names -)"
	echo "$_SNAPDIR_ID"
}

######  #     #  #####  #     #
#     # #     # #     # #     #
#     # #     # #       #     #
######  #     #  #####  #######
#       #     #       # #     #
#       #     # #     # #     #
#        #####   #####  #     #

snapdir_push() {
	# Pushes a directory snapshot to a store.
	#
	# This method will stage the snapshot and then push it to the store.
	#
	# The STORE is a URI of the form:
	#
	#     [store:]//[bucket|host]/[path]
	#
	# For example: s3://my-bucket/my-snapshots or file:///tmp/my-snapshots
	#
	# Usage:
	#
	#     snapdir push \
	#         --store="${STORE}" \
	#         [--id="${ID}"] or ["${DIR}"] \
	#     		[--cache-dir="${CACHE_DIR}"] \
	#         [--(debug|dryrun|verbose)]
	#
	# Returns: snapshot id
	#
	# Examples:
	#
	#     # pushes a snapshot of a directory to a store
	#     snapdir push --store="${STORE}" "${DIR}"
	#
	#     # pushes a staged snapshot id to a store
	#     snapdir push --store="${STORE}" --id="${ID}"
	#
	#     # pushes the stdin provided snapshot id to a store
	#     snapdir id "${DIR}" | snapdir push --store="${STORE}"
	#
	# 	 # show the snapdir-$adapter-store command that would be executed
	#     # for a dry run
	#     snapdir push --store="${STORE}" --verbose --dryrun "${DIR}"
	#
	set -eEuo pipefail
	local store="${_SNAPDIR_STORE:?Missing --store option when calling ${_SNAPDIR} push}"
	local dryrun="${_SNAPDIR_DRYRUN:-false}"
	local verbose="${_SNAPDIR_VERBOSE:-false}"
	local _snapdir_tmp_dir=""
	local push_directory

	# The user might be piping the snapshot or it might be based on an existing snapshot id
	if [[ ${_SNAPDIR_MANIFEST:-""} != "" ]]; then
		# providing both a stdin manifest or via --id and a directory is not allowed
		if [[ ${1:-""} != "" ]]; then
			echo "error: Cannot provide both a manifest and a directory to push." >&2
			return 1
		fi
		# If this is the case, we'll checkout the manifest to a temporary directory as symlinks
		_snapdir_tmp_dir="$(mktemp -d -t "${_SNAPDIR}"_"${_SNAPDIR_ID}".XXXXXXXXXX)"
		_SNAPDIR_LINKED=true snapdir_checkout "$_snapdir_tmp_dir" >/dev/null
		_SNAPDIR_ID=$(_SNAPDIR_VERBOSE=false snapdir_id "${_snapdir_tmp_dir}")
		push_directory=$(_SNAPDIR_KEEP=true _SNAPDIR_VERBOSE=false snapdir_stage "$_snapdir_tmp_dir")
	else
		# Expecting a directory
		_SNAPDIR_ID=$(_SNAPDIR_VERBOSE=false snapdir_id "${1:-"."}")
		push_directory=$(_SNAPDIR_KEEP=true _SNAPDIR_VERBOSE=false snapdir_stage "${1:-"."}")
	fi
	export _SNAPDIR_ID

	local push_command
	push_command="$(_SNAPDIR_VERBOSE=false _snapdir_get_push_command "${push_directory}" "${store}")"
	if [[ ${push_command} != "" ]]; then
		if [[ ${dryrun} == "true" ]]; then
			_snapdir_dryrun_log "Pushing snapshot to store '${store}' with command:"
			_snapdir_dryrun_log "${push_command}"
		else
			local verbose_flag=""
			if [[ $verbose == "true" ]]; then
				verbose_flag="set -x;"
			fi
			bash -c "set -eEuo pipefail;${verbose_flag}${push_command}
			wait" | _snapdir_log
		fi
	else
		_snapdir_log "Nothing to push to '${store}'."
	fi
	rm -rf "$push_directory"
	if [[ ${_snapdir_tmp_dir} != "" ]]; then
		rm -rf "${_snapdir_tmp_dir}"
	fi
	echo "${_SNAPDIR_ID}"
}

####### ####### #######  #####  #     #
#       #          #    #     # #     #
#       #          #    #       #     #
#####   #####      #    #       #######
#       #          #    #       #     #
#       #          #    #     # #     #
#       #######    #     #####  #     #

snapdir_fetch() {
	# Retrieves a snapshot from a store and saves it in the local cache.
	#
	# Usage:
	#
	#     snapdir fetch \
	#         --store="${STORE}" \
	#         --id="${ID}" \
	#         [--(dryrun|verbose)] \
	#         [--cache-dir="${CACHE_DIR}"]
	#
	# Returns: No output unless in --verbose mode. Exit code 1 in case of error.
	#
	# Examples:
	#
	#     # fetches a snapshot from a store and saves it in the local cache
	#     snapdir fetch --store="${STORE}" --id="${ID}" --verbose
	#
	#     # dry run
	#     snapdir fetch --store="${STORE}" --id="${ID}" --dryrun
	#
	set -eEuo pipefail
	local snapdir_id="${_SNAPDIR_ID:?Missing --id option when calling ${_SNAPDIR} fetch}"
	local store="${_SNAPDIR_STORE:?Missing --store option when calling ${_SNAPDIR} push}"
	local manifest_rel_path
	manifest_rel_path="$(_snapdir_get_manifest_rel_path "${snapdir_id}")"
	local dryrun="${_SNAPDIR_DRYRUN:-false}"

	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local manifest_cache_path="$cache_dir/${manifest_rel_path}"
	local tmp_id
	tmp_id="$(_snapdir_tmp_id)"
	local manifest_pipe_path

	local verbose="${_SNAPDIR_VERBOSE:-false}"
	local verbose_flag=""
	if [[ ${verbose} == true ]]; then
		verbose_flag="set -x;"
	fi

	if test -f "${manifest_cache_path}"; then
		manifest_pipe_path="${manifest_cache_path}"
	else
		mkdir -p "$(dirname "${manifest_cache_path}")"
		local fetch_manifest_command
		fetch_manifest_command=$(_snapdir_get_fetch_snapdir_manifest_command "${snapdir_id}" "${store}")
		if [[ ${dryrun} == "true" ]]; then
			_snapdir_dryrun_log "${fetch_manifest_command}"
		fi

		bash -c "set -eEuo pipefail;${fetch_manifest_command}" >"${manifest_cache_path}.${tmp_id}" || {
			echo "error: Failed to fetch manifest for snapshot '${snapdir_id}' from store '${store}' when calling '${fetch_manifest_command}'." >&2
			rm -rf "${manifest_cache_path}.${tmp_id}"
			return 1
		}
		manifest_pipe_path="${manifest_cache_path}.${tmp_id}"
	fi

	local _output_dest="/dev/stdout"
	if [[ ${_SNAPDIR_VERBOSE:-false} == false ]]; then
		_output_dest="/dev/null"
	fi

	# TODO: verify the integrity of the manifest before moving forward
	if [[ "$(grep -v "^#" <"$manifest_pipe_path" | b3sum --no-names)" != "${snapdir_id}" ]]; then
		echo "error: Manifest for snapshot '${snapdir_id}' does not match the snapshot id." >&2
		rm -rf "${manifest_cache_path}.${tmp_id}"
		return 1
	fi

	fetch_files_commands=$(_snapdir_get_fetch_snapdir_files_command <"${manifest_pipe_path}")
	if [[ ${fetch_files_commands} != "" ]]; then
		if [[ ${dryrun} == "true" ]]; then
			_snapdir_dryrun_log "${fetch_files_commands}"
		else
			bash -c "set -eEuo pipefail;
			${fetch_files_commands}
			wait" >"$_output_dest" || {
				rm -rf "${manifest_cache_path}.${tmp_id}"
				echo "error: Failed to fetch files for snapshot '${snapdir_id}' from store '${store}' when calling '${fetch_files_commands}'." >&2
				return 1
			}
		fi
	fi

	if [[ ${dryrun} != "true" ]]; then
		# if the manifest did not exist locally, use them tmp file
		test -f "${manifest_cache_path}" || mv "${manifest_cache_path}.${tmp_id}" "${manifest_cache_path}"
		_snapdir_log "SAVED: ${manifest_cache_path}"
	fi

	rm -rf "${manifest_cache_path}.${tmp_id}"
}

#       ######  #     # #       #
#       #     # #     # #       #
#       #     # #     # #       #
#       ######  #     # #       #
#       #       #     # #       #
#       #       #     # #       #
#       #        #####  ####### #######

snapdir_pull() {
	# Fetches a snapshot from a store and checks it out on a given directory.
	#
	# Usage:
	#
	#     snapdir pull \
	#         --store="${STORE}" \
	#         --id="${ID}" \
	#         [--(dryrun|verbose|force|linked)] \
	#         [--cache-dir="${CACHE_DIR}"]
	#         ["${DIR}"]
	#
	# Returns: No output unless in --verbose mode. Exit code 1 in case of error.
	#
	# Examples:
	#
	#     # fetches a snapshot and checks it out
	#     snapdir pull --store="${STORE}" --id="${ID}" --verbose "${DIR}"
	#
	#     # forces a checkout even if the directory contains modified files
	#     snapdir pull --store="${STORE}" --id="${ID}" --force "${DIR}"
	#
	#     # dry run
	#     snapdir pull --store="${STORE}" --id="${ID}" --dryrun "${DIR}"
	#
	set -eEuo pipefail
	local base_dir
	base_dir="$(_snapdir_get_base_dir "${1:-"."}")"
	local dryrun="${_SNAPDIR_DRYRUN:-false}"

	if [[ ${_SNAPDIR_RETRIES:-} != "" ]]; then
		echo "warning: snapdir_pull ${_SNAPDIR_RETRIES}/retries" >&2
		# exit after _SNAPDIR_MAX_RETRIES
		if [[ ${_SNAPDIR_RETRIES} -gt ${_SNAPDIR_MAX_RETRIES:-3} ]]; then
			echo "error: snapdir_pull failed after ${_SNAPDIR_MAX_RETRIES} retries" >&2
			return 1
		fi
	fi

	snapdir_fetch
	_SNAPDIR_PURGE=true snapdir_verify || {
		_SNAPDIR_RETRIES=${_SNAPDIR_RETRIES:-0}
		_SNAPDIR_RETRIES=$((_SNAPDIR_RETRIES + 1)) snapdir_pull "${base_dir}"
	}
	snapdir_checkout "${base_dir}"
}

######  #     # #######  #####  #    # ####### #     # #######
#     # #     # #       #     # #   #  #     # #     #    #
#       #     # #       #       #  #   #     # #     #    #
#       ####### #####   #       ###    #     # #     #    #
#       #     # #       #       #  #   #     # #     #    #
#     # #     # #       #     # #   #  #     # #     #    #
######  #     # #######  #####  #    # #######  #####     #

snapdir_checkout() {
	# Checks out a snapshot from the cache on a given directory.
	#
	# When the linked option is used, the files are hardlinked instead of copied.
	# This only works if the files are on the same filesystem and it's only
	# recommended for filesystems with copy-on-write (COW) support.
	#
	# Usage:
	#
	#     snapdir checkout \
	#         --store="${STORE}" \
	#         --id="${ID}" \
	#         [--(dryrun|verbose|force|linked)] \
	#         [--cache-dir="${CACHE_DIR}"]
	#         ["${DIR}"]
	#
	# Returns: No output unless in --verbose mode. Exit code 1 in case of error.
	#
	# Examples:
	#
	#     # checks out a snapshot
	#     snapdir checkout --store="${STORE}" --id="${ID}" --verbose "${DIR}"
	#
	#     # forces a checkout even if the directory contains modified files
	#     snapdir checkout --store="${STORE}" --id="${ID}" --force "${DIR}"
	#
	#     # dry run
	#     snapdir checkout --store="${STORE}" --id="${ID}" --dryrun "${DIR}"
	#
	#     # hardlinks files instead of copying them
	#     snapdir checkout --store="${STORE}" --id="${ID}" --linked "${DIR}"
	#
	set -eEuo pipefail
	local base_dir
	base_dir="$(_snapdir_get_base_dir "${1:-"."}" false)"
	local snapdir_id="${_SNAPDIR_ID:?Missing --id option when calling ${_SNAPDIR} checkout}"
	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local manifest_rel_path
	manifest_rel_path="$(_snapdir_get_manifest_rel_path "${snapdir_id}")"
	local dryrun="${_SNAPDIR_DRYRUN:-false}"

	local manifest_cache_path="$cache_dir/${manifest_rel_path}"
	test -f "${manifest_cache_path}" || {
		echo "Manifest not found locally. Did you forget to fetch ${snapdir_id} from the store?" >&2
		return 1
	}
	local only_path=""
	if [[ ${_SNAPDIR_PATH:-""} != "" ]]; then
		only_path="$(_snapdir_absolute_path "${base_dir}/${_SNAPDIR_PATH}")"
	fi

	local actual_manifest
	actual_manifest="$(_SNAPDIR_VERBOSE=false _SNAPDIR_DEBUG=false _SNAPDIR_ID="" _SNAPDIR_MANIFEST="" "${_SNAPDIR_BIN_PATH}" manifest "$base_dir" 2>/dev/null || echo "")"
	local manifest_diff
	# Warning: diff output is pretty inconsistent we will only consider
	# lines that start with '(+|-) (D|F) '
	manifest_diff="$(diff -u <(echo "${actual_manifest}") "$manifest_cache_path" 2>/dev/null | grep -E "^(\+|-) ?(D|F) " || echo "")"
	local additions_manifest
	# we only want new additions made to the manifest. diff will sometimes include
	# an extra space after the + symbol
	additions_manifest="$(echo "${manifest_diff}" | grep '^+' | sed -E 's#^(\+) ?##' || echo "")"

	# We store all state changes in associative arrays so that they only get applied if there are no errors
	local directories=()
	local success_messages=()
	local source_files=()
	local source_perms=()
	local target_files=()

	while read -r line; do
		set -eEuo pipefail
		if [[ ${line:-""} == "" ]]; then
			continue
		fi
		# split line by spaces and define the line_parts array
		IFS=' ' read -r -a line_parts <<<"${line}"
		local type="${line_parts[0]}"
		local permissions="${line_parts[1]}"
		local checksum="${line_parts[2]}"
		local relative_path="${line_parts[4]}"
		local object_dir
		local absolute_path
		absolute_path="$(_snapdir_absolute_path "${base_dir}/${relative_path}")"
		# When providing --path we only want to include the files starting with that path
		if [[ ${only_path} != "" ]]; then
			if grep -v -q "^${only_path}" <<<"${absolute_path}"; then
				continue
			fi
			object_dir="$(dirname "${absolute_path}")"
			test -d "$object_dir" || directories+=("$object_dir")
		fi
		if [[ ${type} == "D" ]]; then
			test -d "$absolute_path" || directories+=("$absolute_path")
		else
			local object_rel_path
			object_rel_path="$(_snapdir_get_object_rel_path "${checksum}")"
			local cache_path="$cache_dir/${object_rel_path}"
			test -f "$cache_path" || {
				# Fatal error
				echo "${absolute_path} with checksum ${checksum} not found on cache. Did you forget to fetch ${snapdir_id} from the store?" >&2
				return 1
			}
			if test -f "$absolute_path"; then
				if [[ ${_SNAPDIR_FORCE:-false} == false ]]; then
					# Fatal error
					echo "File ${absolute_path} already exists. To override file, use the --force flag." >&2
					return 1
				else
					success_messages+=("Existing ${absolute_path} file overwritten via --force flag.")
				fi
			fi
			_snapdir_log "Checking out ${absolute_path} with checksum ${checksum}"
			source_files+=("$cache_path")
			target_files+=("$absolute_path")
			source_perms+=("$permissions")
		fi
	done <<<"${additions_manifest}"

	if [[ ${_SNAPDIR_VERBOSE:-""} == "true" ]]; then
		local unchanged_files
		unchanged_files="$(diff -u <(echo "${actual_manifest}" | grep "^F ") <(echo "${additions_manifest}" | grep "^F ") 2>/dev/null | grep -E "^- ?" | sed -E 's#^(-) ?##' | cut -d' ' -f5 || echo "")"
		local absolute_path
		for relative_path in ${unchanged_files}; do
			absolute_path="$(_snapdir_absolute_path "${base_dir}/${relative_path}")"
			if [[ ${only_path} != "" ]] && grep -v -q "^${only_path}" <<<"${absolute_path}"; then
				continue
			fi
			_snapdir_log "${absolute_path} is up to date"
		done

		# print success messages from
		# using safe idiom to iterate over arrays on bash >= 4.0
		for ((i = 0; i < ${#success_messages[@]}; i++)); do
			_snapdir_log "${success_messages[$i]}"
		done
	fi

	if [[ ${dryrun} == "true" ]]; then
		# unique list of directories
		# using safe idiom to iterate over arrays on bash >= 4.0
		for ((i = 0; i < ${#directories[@]}; i++)); do
			_snapdir_dryrun_log "mkdir -p \"${directories[$i]}\""
		done

		if [[ ${_SNAPDIR_LINKED:-false} == true ]]; then
			# link all files
			for ((i = 0; i < ${#source_files[@]}; i++)); do
				_snapdir_dryrun_log "ln \"${source_files[$i]}\" \"${target_files[$i]}\""
			done
		else
			# copy all sources to targets and set permissions
			for ((i = 0; i < ${#source_files[@]}; i++)); do
				_snapdir_dryrun_log "cp -a \"${source_files[$i]}\" \"${target_files[$i]}\""
				_snapdir_dryrun_log "chmod \"${source_perms[$i]}\" \"${target_files[$i]}\""
			done
		fi
	else
		# using safe idiom to iterate over arrays on bash >= 4.0
		for ((i = 0; i < ${#directories[@]}; i++)); do
			mkdir -p "${directories[$i]}"
		done

		if [[ ${_SNAPDIR_LINKED:-false} == true ]]; then
			# link all files
			for ((i = 0; i < ${#source_files[@]}; i++)); do
				ln "${source_files[$i]}" "${target_files[$i]}"
			done
		else
			# copy all sources to targets and set permissions
			for ((i = 0; i < ${#source_files[@]}; i++)); do
				cp -a "${source_files[$i]}" "${target_files[$i]}"
				chmod "${source_perms[$i]}" "${target_files[$i]}"
			done
		fi
	fi
}

#     #####  #######    #     #####  #######
#    #     #    #      # #   #     # #
#    #          #     #   #  #       #
#     #####     #    #     # #  #### #####
#          #    #    ####### #     # #
#    #     #    #    #     # #     # #
#     #####     #    #     #  #####  #######

snapdir_stage() {
	# Stages the files in a given directory into the local cache.
	#
	# Usage:
	#
	#     snapdir stage ["${DIR}"] \
	#         [--cache-dir="${CACHE_DIR}"]
	#         [--(keep|verbose)]
	#
	# Returns: The manifest id or the staging directory when --keep is provided.
	#
	# Examples:
	#
	#     # Stages the current directory so that it can be
	#     # pushed to the store or checked out elsewhere locally.
	#     snapdir stage
	#
	#     # stages a given directory and keeps the staging directory
	#     snapdir stage "${DIR}" --keep # this prints the staging directory
	#
	#     # stages a to a custom cache directory
	#     snapdir stage "${DIR}" --cache-dir="${CACHE_DIR}" --verbose
	#
	set -eEuo pipefail

	# ensure objects from the directory are on the cache
	_snapdir_cache_objects "${1:-""}"

	local base_dir
	base_dir="$(_snapdir_get_base_dir "${1:-""}")"
	local manifest="${_SNAPDIR_MANIFEST:-$(snapdir_manifest "${base_dir}")}"
	_SNAPDIR_MANIFEST="${manifest}"
	local snapdir_id
	snapdir_id="$(snapdir_manifest "$base_dir" | grep -v "^#" | b3sum --no-names -)"
	_SNAPDIR_ID="${snapdir_id}"
	local staging_directory
	staging_directory="$(mktemp -d -t "${_SNAPDIR}"_"${snapdir_id}".XXXXXXXXXX)"

	local manifest_rel_path
	manifest_rel_path="$(_snapdir_get_manifest_rel_path "${snapdir_id}")"

	mkdir -p "$staging_directory/$(dirname "${manifest_rel_path}")"
	local staged_manifest_path="$staging_directory/${manifest_rel_path}"
	echo "${manifest}" >"$staged_manifest_path"
	# ensure the staged manifest b3sum matches the snapshot id
	local staged_manifest_b3sum
	staged_manifest_b3sum="$(grep -v "^#" <"$staged_manifest_path" | b3sum --no-names)"
	if [[ ${staged_manifest_b3sum} != "${snapdir_id}" ]]; then
		echo "Staged manifest $staged_manifest_path b3sum does not match snapshot id ${snapdir_id}." >&2
		return 1
	fi

	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"

	local checksum
	local rel_path
	local object_rel_path
	local object_rel_dir
	local cache_path
	local symlink_path
	local line_parts
	local object_type

	for line in $manifest; do
		IFS=' ' read -r -a line_parts <<<"${line}"
		object_type="${line_parts[0]}"
		if [[ ${object_type} != "F" ]]; then
			continue
		fi

		checksum="${line_parts[2]}"
		object_rel_path="$(_snapdir_get_object_rel_path "${checksum}")"

		# we only need to create the staging directory if --keep is provided
		if [[ ${_SNAPDIR_KEEP:-"false"} == "true" ]]; then
			symlink_path="$staging_directory/${object_rel_path}"
			if [[ ! -e $symlink_path ]]; then
				cache_path="$cache_dir/${object_rel_path}"
				_snapdir_log "Linking ${cache_path} to ${symlink_path}"
				object_rel_dir="$(dirname "${object_rel_path}")"
				mkdir -p "$staging_directory/${object_rel_dir}"
				# use softlink to allow the cache and the staging area to be on different volumes
				ln -s "${cache_path}" "$symlink_path"
			fi
		fi
	done

	_snapdir_cache_manifest

	if [[ ${_SNAPDIR_KEEP:-"false"} == "true" ]]; then
		echo "$staging_directory"
	else
		rm -rf "$staging_directory"
		echo "$snapdir_id"
	fi
}

#       #     # ####### ######  ### ####### #     #
#       #     # #       #     #  #  #        #   #
#       #     # #       #     #  #  #         # #
#       #     # #####   ######   #  #####      #
#        #   #  #       #   #    #  #          #
#         # #   #       #    #   #  #          #
#          #    ####### #     # ### #          #

snapdir_verify() {
	# Verifies the integrity of a snapshot.
	#
	# Usage:
	#     snapdir verify \
	#         --id="${ID}" \
	#         [--cache-dir="${CACHE_DIR}"]
	#         [--(purge|verbose)]
	#
	# Returns: Exits with 0 if the snapshot is valid, 1 otherwise.
	#
	# Examples:
	#
	#     # verify a snapshot that has been cached locally
	#     snapdir verify --id="${ID}" --verbose
	#
	#     # verify and purge invalid objects from the cache
	#     snapdir verify --id="${ID}" --purge
	#
	set -eEuo pipefail
	local purge="${_SNAPDIR_PURGE:-false}"

	# Fail if the cache directory is set
	if [[ ${1:-""} != "" ]]; then
		echo "error: Cannot verify a directory. Only staged manifests can be verified providing their --id." >&2
		echo "error: Please remove the path '$1' from the command." >&2
		return 1
	fi

	# When purge is enabled, we'll buffer the result of b3sum to remove FAILED objects
	if [[ ${purge} == "true" ]]; then
		local result
		result="$(_snapdir_check_integrity 2>&1 || echo "")"
		local failed_objects
		failed_objects="$(echo "$result" | grep -E ': FAILED' | cut -d ':' -f1 | tr '\n' ' ')"
		echo "$result"
		if [[ ${failed_objects:-""} != "" ]]; then
			# trim the trailing space
			failed_objects="${failed_objects% }"
			echo "warning: Removing corrupted objects: ${failed_objects}" >&2
			echo "$failed_objects" | xargs rm -f
			return 1
		fi
	else
		_snapdir_check_integrity
	fi
}

#    #     # ####### ######  ### ####### #     #     #####     #     #####  #     # #######
#    #     # #       #     #  #  #        #   #     #     #   # #   #     # #     # #
#    #     # #       #     #  #  #         # #      #        #   #  #       #     # #
#    #     # #####   ######   #  #####      #       #       #     # #       ####### #####
#     #   #  #       #   #    #  #          #       #       ####### #       #     # #
#      # #   #       #    #   #  #          #       #     # #     # #     # #     # #
#       #    ####### #     # ### #          #        #####  #     #  #####  #     # #######

snapdir_verify_cache() {
	# Verifies the integrity of all the objects in the cache.
	#
	# Usage:
	#
	#     snapdir verify-cache \
	#         [--cache-dir="${CACHE_DIR}"]
	#         [--(purge|verbose)]
	#
	# Returns: Exits with 0 if all the objects are valid, 1 otherwise.
	#
	# Example:
	#
	#     # verify all the objects in the cache and purges invalid objects
	#     snapdir verify-cache --verbose --purge
	#
	set -eEuo pipefail
	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local purge="${_SNAPDIR_PURGE:-false}"
	local failed=false
	test -d "${cache_dir}"/.objects || return 0
	while read -r line; do
		set -eEuo pipefail
		local checksum
		local expected_checksum
		checksum="$(echo "$line" | cut -d' ' -f1)"
		expected_checksum="$(echo "$line" | cut -d' ' -f2)"
		if [[ ${checksum} != "${expected_checksum}" ]]; then
			_snapdir_log "${expected_checksum} FAILED"
			failed=true
			echo "Checksum mismatch for ${expected_checksum}" >&2
			if [[ ${purge} == "true" ]]; then
				rm "${cache_dir}/$(_snapdir_get_object_rel_path "${expected_checksum}")"
			fi
		else
			_snapdir_log "${expected_checksum} OK"
		fi
	done <<<"$(b3sum "${cache_dir}"/.objects/*/*/*/* | sed 's| .*.objects/| |; s|/||g' 2>&1 || echo "")"
	if [[ ${failed} == "true" ]]; then
		return 1
	fi
}

####### #       #     #  #####  #     #     #####     #     #####  #     # #######
#       #       #     # #     # #     #    #     #   # #   #     # #     # #
#       #       #     # #       #     #    #        #   #  #       #     # #
#####   #       #     #  #####  #######    #       #     # #       ####### #####
#       #       #     #       # #     #    #       ####### #       #     # #
#       #       #     # #     # #     #    #     # #     # #     # #     # #
#       #######  #####   #####  #     #     #####  #     #  #####  #     # #######

snapdir_flush_cache() {
	# Empties the local cache.
	#
	# Usage:
	#
	#     snapdir verify-cache \
	#         [--cache-dir="${CACHE_DIR}"]
	#
	set -eEuo pipefail
	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	rm -rf "${cache_dir}"
}

######  ####### #######    #    #     # #       #######  #####
#     # #       #         # #   #     # #          #    #     #
#     # #       #        #   #  #     # #          #    #
#     # #####   #####   #     # #     # #          #     #####
#     # #       #       ####### #     # #          #          #
#     # #       #       #     # #     # #          #    #     #
######  ####### #       #     #  #####  #######    #     #####

snapdir_defaults() {
	# Shows the default environment variables and options.
	#
	# Usage:
	#
	#     snapdir defaults
	#
	set -eEuo pipefail
	{
		"${_SNAPDIR_BIN_DIR}/snapdir-manifest" defaults | grep -v "^-"
		env | grep "SNAPDIR" | grep -v VERSION | sed -E 's|^_?SNAPDIR_|--|; s|_|-|g;' | tr '[:upper:]' '[:lower:]' | sort
		echo "SNAPDIR_BIN_PATH=${SNAPDIR_BIN_PATH:-$_SNAPDIR_BIN_PATH}"
	} | sort -u
}

######  ######  ### #     #    #    ####### #######    ####### #     #  #####
#     # #     #  #  #     #   # #      #    #          #       ##    # #     #
#     # #     #  #  #     #  #   #     #    #          #       # #   # #
######  ######   #  #     # #     #    #    #####      #####   #  #  #  #####
#       #   #    #   #   #  #######    #    #          #       #   # #       #
#       #    #   #    # #   #     #    #    #          #       #    ## #     #
#       #     # ###    #    #     #    #    #######    #       #     #  #####

######  #     # #     #
#     # #     # ##    #
#     # #     # # #   #
######  #     # #  #  #
#   #   #     # #   # #
#    #  #     # #    ##
#     #  #####  #     #

_snapdir_run() (
	# run in a subshell to avoid polluting the environment with helper functions
	# You can call this function when sourcing this script if you want to expose it as
	# a sub-command

	# Saves the command into the run log for debugging, documentation, etc.
	if [[ ${ENVIRONMENT:-""} == "test" ]] && [[ ${_SNAPDIR_RUN_LOG_PATH:-""} != "" ]] && test -f "${_SNAPDIR_RUN_LOG_PATH:-""}"; then
		# shellcheck disable=SC2145
		echo "snapdir ${@}" >>"${_SNAPDIR_RUN_LOG_PATH}"
	fi

	set -eEuo pipefail
	local subcommands="manifest|id|stage|checkout|fetch|pull|push|verify|verify-cache|flush-cache|test|defaults"
	local boolean_args="debug|force|linked|keep|purge|stage|verbose|dryrun"
	local value_required_args="id|store|cache_dir|path|exclude"
	local legal_argument_keys="${boolean_args}|${value_required_args}"

	parse_argument_key() {
		sed -E 's|^--?|_SNAPDIR_|; s|-|_|g;' <<<"${1^^}"
	}

	validate_option() {
		set -eEuo pipefail
		grep -q -E "^_SNAPDIR_(${legal_argument_keys^^})$" <<<"${1}" || {
			echo "error: Unknown option: ${1//_SNAPDIR_/}" | tr '[:upper:]' '[:lower:]' >&2
			echo "Valid options are: --(${legal_argument_keys})" >&2
			exit 1
		}
	}

	_snapdir_parse_argument_key() {
		sed -E 's|^--?|_SNAPDIR_|; s|-|_|g;' <<<"${1^^}"
	}

	_snapdir_validate_option() {
		set -eEuo pipefail
		grep -q -E "^_SNAPDIR_(${legal_argument_keys^^})$" <<<"${1}" || {
			echo "error: Unknown option: ${1//_SNAPDIR_/}" | tr '[:upper:]' '[:lower:]' >&2
			echo "Valid options are: --(${legal_argument_keys})" >&2
			exit 1
		}
	}

	_snapdir_help() {
		_snapdir_export_env_defaults
		local command="${1:-""}"
		if [[ ${command} == "" ]]; then
			sed '/# LICENSE: MIT Copyright (c) 2022 Bermi Ferrer/q; 1,2d' "$_SNAPDIR_BIN_PATH" | sed -E 's|^# ?||g; $d' | more
		else
			_snapdir_command_help "snapdir_${command//-/_}" <"$_SNAPDIR_BIN_PATH" | more
		fi
		exit 0
	}

	local command=""
	local positional_args=""
	local key
	local value
	local is_boolean
	local subcommand_candidate="${1:-""}"
	local show_help=false
	while [ $# -gt 0 ]; do
		case "$1" in
		manifest | id | stage | checkout | fetch | pull | push | verify | verify-cache | flush-cache | test | defaults)
			# if command is already set, compain about multiple commands
			if [ -n "$command" ]; then
				echo "error: multiple commands specified: $command $1" >&2
				return 1
			fi
			command="$1"
			shift
			;;
		help | -h | --help)
			show_help=true
			shift
			;;
		version | -v | --version)
			echo "${_SNAPDIR_VERSION}"
			exit 0
			;;
		# export all --*=* flags as _SNAPDIR_* env vars
		--*=* | -*=*)
			key="$(parse_argument_key "${1%%=*}")"
			validate_option "$key"
			export "$key"="${1#*=}"
			shift
			;;
		# export all --* * flags as _SNAPDIR_* env vars
		--*)
			is_boolean=$(grep -q -E "^--?(${boolean_args})$" <<<"${1}" && echo true || echo false)
			key="$(parse_argument_key "${1}")"
			validate_option "$key"
			shift
			value="${1:-true}"
			# if key is in boolean_args
			if [[ ${is_boolean} == "false" ]] && [[ ${value:0:1} != "-" ]]; then
				# since this might be the last arg, this will always be truthy
				shift || true
			else
				value="true"
			fi
			export "${key}"="${value}"
			;;
		*)
			positional_args="${positional_args}${1} "
			shift
			;;
		esac
	done

	if [[ ${show_help} == "true" ]]; then
		_snapdir_help "$command"
	fi

	# if command is not set, show help
	if [ -z "$command" ]; then
		if [[ $subcommand_candidate != "" ]]; then
			echo "Uknown command '$subcommand_candidate'. Valid commands are: ${subcommands}" >&2
			echo "Try: ${_SNAPDIR} --help" >&2
			return 1
		else
			_snapdir_help
			echo "Valid snapdir commands are: ${subcommands}" >&2
			return 1
		fi
	fi

	_snapdir_export_env_defaults "${command}"
	eval "snapdir_${command//-/_} $positional_args ${*:2}"
)

_snapdir_cache_objects() {
	# Caches the files from a directory into the local cache.
	#
	set -eEuo pipefail
	local base_dir
	base_dir="$(_snapdir_get_base_dir "${1:-""}")"
	local manifest="${_SNAPDIR_MANIFEST:-$(snapdir_manifest "${base_dir}")}"
	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local checksum
	local rel_path
	local object_rel_path
	local object_rel_dir
	local cache_path
	local line_parts
	local manifest_files
	manifest_files="$(echo "${manifest}" | grep '^F ' || echo "")"

	for line in $manifest_files; do
		IFS=' ' read -r -a line_parts <<<"${line}"
		checksum="${line_parts[2]}"
		object_rel_path="$(_snapdir_get_object_rel_path "${checksum}")"
		rel_path="${line_parts[4]}"
		file_path="$(_snapdir_absolute_path "${base_dir}/${rel_path}")"
		# Caches the object and verifies the checksum
		cache_path="$cache_dir/${object_rel_path}"

		# prevent overwriting unchanged files in order to avoid unnecessary inotify events
		if ! test -f "${cache_path}"; then
			_snapdir_log "Caching ${cache_path}"
			object_rel_dir="$(dirname "${object_rel_path}")"
			mkdir -p "$cache_dir/${object_rel_dir}"
			# Files on the cache should be immutable
			# TODO: On COW filesystems, it will be more
			# efficient to link the file instead of copying it.
			cp "${file_path}" "${cache_path}"
			chmod 600 "${cache_path}"
		else
			_snapdir_log "Object cache for ${file_path} alredy exists"
		fi
	done
}

_snapdir_cache_manifest() {
	# Saves the manifest in the local cache.
	set -eEuo pipefail
	: "${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local manifest="${_SNAPDIR_MANIFEST:?Missing manifest contents}"
	snapdir_id >/dev/null
	echo "$manifest" | _snapdir_save_manifest_on_cache
}

_snapdir_get_fetch_snapdir_manifest_command() {
	set -eEuo pipefail
	local snapdir_id="${_SNAPDIR_ID:?Missing --id option}"
	local store="${_SNAPDIR_STORE:?Missing --store option}"
	local store_bin_path
	store_bin_path=$(_snapdir_get_store_bin_path "${store}")
	$store_bin_path get-manifest-command --id "${snapdir_id}" --store "${store}"
}

_snapdir_get_fetch_snapdir_files_command() {
	# reads the manifest from stdin
	set -eEuo pipefail
	local snapdir_id="${_SNAPDIR_ID:?Missing --id option}"
	local store="${_SNAPDIR_STORE:?Missing --store option}"
	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local store_bin_path
	store_bin_path=$(_snapdir_get_store_bin_path "${store}")
	$store_bin_path get-fetch-files-command --id "${snapdir_id}" --store "${store}" --cache-dir "${cache_dir}"
}

_snapdir_get_store_bin_path() {
	local store_protocol
	local store="${1:?Missing store}"
	_snapdir_export_store_vars
	store_protocol="$(echo "${store}" | cut -d':' -f1)"
	local store_bin_path
	local explicit_bin_path
	grep -q "^[a-z0-9]*$" <<<"$store_protocol" || {
		echo "Invalid store protocol: '${store_protocol}'" >&2
		return 1
	}
	explicit_bin_path="_SNAPDIR_${store_protocol^^}_STORE_BIN_PATH"
	# if explicit_bin_path is defined, use it
	if [[ ${!explicit_bin_path:-""} != "" ]] && test -f "${!explicit_bin_path}"; then
		echo "${!explicit_bin_path}"
		return 0
	fi
	if test -f "${_SNAPDIR_BIN_DIR}/snapdir-${store_protocol}-store"; then
		echo "${_SNAPDIR_BIN_DIR}/snapdir-${store_protocol}-store"
		return 0
	fi
	store_bin_path=$("snapdir-${store_protocol}-store" -v || echo "" 2>/dev/null)
	if [[ ${store_bin_path} == "" ]]; then
		echo "Unsupported store protocol: ${store_protocol}" >&2
		echo "No 'snapdir-${store_protocol}-store' could be found on your PATH" >&2
		return 1
	fi
	echo "${store_bin_path}"
}

_snapdir_get_push_command() {
	set -eEuo pipefail
	local staging_directory="${1:?Missing staging directory}"
	local store="${2:?Missing store}"
	local store_bin_path
	store_bin_path=$(_snapdir_get_store_bin_path "${store}")
	$store_bin_path get-push-command \
		--id "${_SNAPDIR_ID}" \
		--staging-dir "${staging_directory}" \
		--store "${store}"
}

_snapdir_get_manifest_rel_path() {
	set -eEuo pipefail
	local snapdir_id="${1:-${_SNAPDIR_ID:?Missing --id option}}"
	echo ".manifests/${snapdir_id:0:3}/${snapdir_id:3:3}/${snapdir_id:6:3}/${snapdir_id:9}"
}

_snapdir_get_manifest_rel_base() {
	set -eEuo pipefail
	local snapdir_id="${1:-${_SNAPDIR_ID:?Missing --id option}}"
	echo ".manifests/${snapdir_id:0:3}/${snapdir_id:3:3}/${snapdir_id:6:3}/"
}

_snapdir_get_object_rel_path() {
	set -eEuo pipefail
	local checksum="${1:?Missing object checksum}"
	echo ".objects/${checksum:0:3}/${checksum:3:3}/${checksum:6:3}/${checksum:9}"
}

_snapdir_get_base_dir() {
	set -eEuo pipefail
	local base_dir="${1:-${_SNAPDIR_CWD}}"
	local verify=${2:-true}
	local create=${3:-$_SNAPDIR_CREATE_MISSING_BASE_DIR}
	# resolve to absolute path
	base_dir="$(_snapdir_absolute_path "${base_dir}")"
	if [[ ${create} == "true" ]]; then
		mkdir -p "${base_dir}"
	fi
	if [[ ${verify} == "true" ]] && ! test -d "${base_dir}"; then
		echo "error: Base directory '${base_dir}' does not exist." >&2
		return 1
	fi
	echo "${base_dir}"
}

_snapdir_command_help() {
	set -eEuo pipefail
	local command="${1:?Missing command}"
	local contents
	contents=$(cat)
	echo "$contents" | _snapdir_get_function_body "$command" | sed -E 's|# ?|#|' | _snapdir_get_doc_block_from_function_body
}

_snapdir_get_function_body() {
	set -eEuo pipefail
	local command="${1// /_}"
	local function_name
	function_name="$(echo "$command" | tr '-' '_')"
	local script_contents
	script_contents=$(cat)
	echo "$script_contents" | sed -E -n "/^${function_name} ?\(\)/,/^}/p" | sed -E -n "/^${function_name} ?\(\)/,/^}/p" | grep -v "${function_name}(" | grep -v "^}" | sed -E 's|^\t||'
}

_snapdir_get_doc_block_from_function_body() {
	set -eEuo pipefail
	local function_body
	function_body="$(cat)"
	# get the first line number that does not
	# start with #
	local first_line_number
	first_line_number=$(echo "$function_body" | grep -n "^[^#]" | head -n 1 | cut -d ':' -f1 || true)
	if [[ ${first_line_number:-""} == "" ]]; then
		echo "ERROR: No documentation found"
		return
	fi
	# show the first line number - 1
	echo "$function_body" | sed -n 1,"$((first_line_number - 1))"p | sed -E 's|^#||'
}

# shellcheck disable=SC2295
_snapdir_get_relative_path() {
	# implements 'realpath --relative-to='' using pure bash
	# for systems without coreutils or using bussybox.
	# It doesn't require directories to exist.
	set -eEuo pipefail
	local source="${1:?Missing source path}"
	local target="${1:?Missing target path}"
	local result=""

	local common_prefix="$source"
	while [[ ${target#$common_prefix} == "${target}" ]]; do
		common_prefix="$(dirname "${common_prefix}")"
		if [[ ${result} == "" ]]; then
			result=".."
		else
			result="../${result}"
		fi
	done
	if [[ $common_prefix == "/" ]]; then
		# no common prefix for root
		result="/"
	fi

	local non_common_part="${target#$common_prefix}"
	if [[ ${non_common_part} != "" ]]; then
		if [[ ${result} != "" ]]; then
			result="${result}${non_common_part}"
		else
			# result strips leading /
			result="${non_common_part:1}"
		fi
	fi
	echo "${result}"
}

_snapdir_set_manifest_from_id() {
	set -eEuo pipefail
	local manifest_cache_path
	if _snapdir_is_valid_id "$_SNAPDIR_ID"; then
		manifest_cache_path="${_SNAPDIR_CACHE_DIR}/$(_snapdir_get_manifest_rel_path)"
		if test -f "${manifest_cache_path}"; then
			_SNAPDIR_MANIFEST="$(cat "${manifest_cache_path}")"
		elif [[ ${_SNAPDIR_REQUIRE_STAGED_ID} == "true" ]]; then
			echo "error: Manifest for snapdir ID '${_SNAPDIR_ID}' not found in the local cache. Snapshots must be fetched or staged locally first." >&2
			return 1
		fi
	fi
}

_snapdir_is_valid_id() {
	set -eEuo pipefail
	local id="${1:?Missing id}"
	if grep -E -q "^[a-f0-9]{64}$" <<<"$id"; then
		return 0
	fi
	return 1
}

_snapdir_set_manifest_from_stdin_or_id() {
	set -eEuo pipefail
	if [[ ${_SNAPDIR_ID:-""} != "" ]]; then
		_snapdir_set_manifest_from_id
	fi

	# Are we receiving a manifest via stdin?
	if [[ ${_SNAPDIR_MANIFEST:-""} == "" ]] && [[ -p /dev/stdin ]]; then
		_SNAPDIR_MANIFEST="$(cat)"
		# some callers like Docker RUN might provide an empty /dev/stdin
		if [[ ${_SNAPDIR_MANIFEST} != "" ]]; then
			# if _SNAPDIR_MANIFEST is a 64 char hex string, it is a manifest id
			if _snapdir_is_valid_id "$_SNAPDIR_MANIFEST"; then
				_SNAPDIR_ID="$_SNAPDIR_MANIFEST"
				unset _SNAPDIR_MANIFEST
				_snapdir_set_manifest_from_id
				return 0
			fi
			local dir_candidate="$_SNAPDIR_MANIFEST"
			# remove lines that don't match the manifest format
			_SNAPDIR_MANIFEST="$(echo "${_SNAPDIR_MANIFEST}" | grep -E "(D|F) [0-9]+ [a-f0-9]+ [0-9]+ .*" || echo "")"
			if [[ ${_SNAPDIR_MANIFEST} == "" ]]; then
				if test -d "$dir_candidate"; then
					unset _SNAPDIR_MANIFEST
					_SNAPDIR_CWD="$dir_candidate"
				else
					echo "error: Manifest or manifest ID provided through stdin is invalid." >&2
					exit 1
				fi
			fi
			_SNAPDIR_ID="$(snapdir_id)"
		fi
	fi
}

_snapdir_export_env_defaults() {
	# Environment variables
	set -eEuo pipefail
	local command="${1:-none}"

	_SNAPDIR_CREATE_MISSING_BASE_DIR=false
	_SNAPDIR_REQUIRE_STAGED_ID=false
	if [[ $command == "pull" ]]; then
		_SNAPDIR_CREATE_MISSING_BASE_DIR=true
	elif [[ $command == "id" ]] || [[ $command == "manifest" ]] || [[ $command == "push" ]]; then
		_SNAPDIR_REQUIRE_STAGED_ID=true
	fi

	_SNAPDIR_CACHE_DIR="${_SNAPDIR_CACHE_DIR:-"${HOME:-~}/.cache/${_SNAPDIR}/"}"
	# remove trailing slash from _SNAPDIR_CACHE_DIR
	_SNAPDIR_CACHE_DIR="${_SNAPDIR_CACHE_DIR%/}"
	_SNAPDIR_VERBOSE=${_SNAPDIR_VERBOSE:-"false"}
	_SNAPDIR_FORCE=${_SNAPDIR_FORCE:-"false"}
	_SNAPDIR_CWD="${_SNAPDIR_CWD:-$(pwd)}"
	_SNAPDIR_BIN_DIR="$(dirname "${_SNAPDIR_BIN_PATH}")"
	_SNAPDIR_EXCLUDE="${_SNAPDIR_EXCLUDE:-""}"
	_snapdir_set_manifest_from_stdin_or_id
	_snapdir_export_store_vars

	# If _SNAPDIR_DEBUG=true we'll set -x for every command.
	if [[ ${_SNAPDIR_DEBUG:-""} == "true" ]]; then
		set -x
		_SNAPDIR_VERBOSE=true
	fi

	export _SNAPDIR_CWD \
		_SNAPDIR_CACHE_DIR \
		_SNAPDIR_VERBOSE \
		_SNAPDIR_BIN_DIR \
		_SNAPDIR_EXCLUDE \
		_SNAPDIR_CREATE_MISSING_BASE_DIR \
		_SNAPDIR_FORCE
}

_snapdir_tmp_id() {
	# Caveat: in macOS the resolution is not nanoseconds but in seconds, therefore
	# we include a random suffix to reduce the chance of collisions.
	echo "${RANDOM:-""}$(date +%s%N).tmp"
}

_snapdir_export_store_vars() {
	set -eEuo pipefail
	if [[ ${_SNAPDIR_STORE:-""} != "" ]]; then
		# _SNAPDIR_STORE is formatted as protocol://bucket/base/dir
		if [[ ${_SNAPDIR_STORE_BUCKET:-""} == "" ]]; then
			_SNAPDIR_STORE_BUCKET="$(echo "$_SNAPDIR_STORE" | cut -d'/' -f3)"
			export _SNAPDIR_STORE_BUCKET
		fi
		if [[ ${_SNAPDIR_STORE_BASE_DIR:-""} == "" ]]; then
			_SNAPDIR_STORE_BASE_DIR="$(echo "$_SNAPDIR_STORE" | cut -d'/' -f4-)"
			export _SNAPDIR_STORE_BASE_DIR
		fi
	fi
}

_snapdir_save_manifest_on_cache() {
	# when the manifest is provided via STDIN we'll save it on the cache dir
	set -eEuo pipefail
	local manifest_rel_path
	manifest_rel_path="$(_snapdir_get_manifest_rel_path "${_SNAPDIR_ID}")"
	local manifest_cache_path="${_SNAPDIR_CACHE_DIR}/${manifest_rel_path}"
	if ! test -f "${manifest_cache_path}"; then
		mkdir -p "$(dirname "${manifest_cache_path}")"
		local tmp_id
		tmp_id="$(_snapdir_tmp_id)"
		echo "$_SNAPDIR_MANIFEST" >"${manifest_cache_path}.${tmp_id}"
		_snapdir_log "Saving manifest ${_SNAPDIR_ID} as ${manifest_cache_path}"
		mv "${manifest_cache_path}.${tmp_id}" "${manifest_cache_path}"
		chmod 600 "${manifest_cache_path}"
	fi
}

_snapdir_check_integrity() {
	set -eEuo pipefail
	local snapdir_id="${_SNAPDIR_ID:?Missing --id option when calling ${_SNAPDIR} checkout}"
	local cache_dir="${_SNAPDIR_CACHE_DIR:?Missing --cache-dir option}"
	local manifest_rel_path
	manifest_rel_path="$(_snapdir_get_manifest_rel_path "${snapdir_id}")"
	local manifest_cache_path="${cache_dir}/${manifest_rel_path}"

	test -f "${manifest_cache_path}" || {
		echo "Manifest not found locally. Did you forget to fetch ${snapdir_id} from the store?" >&2
		return 1
	}

	local verbose_flag="--quiet"
	if [[ ${_SNAPDIR_VERBOSE:-""} == "true" ]]; then
		verbose_flag=""
	fi
	# shellcheck disable=SC2086
	{
		echo "${snapdir_id}  ${manifest_cache_path}"
		while read -r checksum; do
			echo "${checksum}  ${cache_dir}/$(_snapdir_get_object_rel_path "${checksum}")"
		done <<<"$(grep -v "/$" "${manifest_cache_path}" | cut -d' ' -f 3)"
	} | b3sum --check $verbose_flag
}

_snapdir_log() {
	set -eEuo pipefail
	if [[ ${1:-"_piped"} == "_piped" ]]; then
		if [[ ${_SNAPDIR_VERBOSE:-""} == "true" ]]; then
			sed -E "s/^/# [$_SNAPDIR] /g" >&2
		else
			cat >/dev/null
		fi
	elif [[ ${_SNAPDIR_VERBOSE:-""} == "true" ]]; then
		echo "$1" | sed -E "s/^/# [$_SNAPDIR] /g" >&2
	fi
}

_snapdir_dryrun_log() {
	set -eEuo pipefail
	while read -r line; do
		echo "# [$_SNAPDIR][dryrun] $line"
	done <<<"$1"
}

#       ####### #######  #####  #######  #####
#          #    #       #     #    #    #     #
#          #    #       #          #    #
#          #    #####    #####     #     #####
#          #    #             #    #          #
#          #    #       #     #    #    #     #
#          #    #######  #####     #     #####

# note: using subshell – '(' instead of '{' – to avoid leaking helper functions
snapdir_test() (
	# Runs the tests for the snapdir command.
	#
	# Requires the helper script [snapdir-test](./snapdir-test) to be on the same directory.
	#
	# Usage:
	#
	#     snapdir test
	#
	set -eEuo pipefail

	# Import test utilities
	# shellcheck disable=SC1091 source=./snapdir-test
	. "${_SNAPDIR_BIN_DIR}/snapdir-test" "${_SNAPDIR_BIN_PATH}"

	test_suite() {
		set -eEuo pipefail
		local result=""
		local expected=""
		local _dir="${_SNAPDIR_TEST_TMP_DIR}/files"
		local snapshot="${_SNAPDIR_BIN_PATH}"
		local foo_checksum="49dc870df1de7fd60794cebce449f5ccdae575affaa67a24b62acb03e039db92"
		local foo_path="49d/c87/0df/1de7fd60794cebce449f5ccdae575affaa67a24b62acb03e039db92"
		local bar_checksum="b3199d36d434044e6778b77d13f8dbaba32a73d9522c1ae8d0f73ef1ff14e71f"
		local bar_path="b31/99d/36d/434044e6778b77d13f8dbaba32a73d9522c1ae8d0f73ef1ff14e71f"
		local nested_manifest_id="709eb24c97350626cda3e1f8bf7ff80fb7635c50d5a038e72919556dbbc79fd1"
		local simple_manifest_id="aa91e498f401ea9e6ddbaa1138a0dbeb030fab8defc1252d80c77ebefafbc70d"
		local simple_manifest_path="aa9/1e4/98f/401ea9e6ddbaa1138a0dbeb030fab8defc1252d80c77ebefafbc70d"
		local simple_manifest="D 700 e2b4329871fef9f50a20ba5d1475ee474f1df4091fe49002fd2bbcc42e6a04d5 8 ./
F 600 $bar_checksum 4 ./bar
F 600 $foo_checksum 4 ./foo"

		# --------------------------------------------------------------------------------
		# snapshot manifest
		# --------------------------------------------------------------------------------
		generate_files
		describe "snapshot manifest for '${_dir}'"
		check "should generate manifest"
		result=$("${snapshot}" manifest "${_dir}" 2>&1 || echo "")
		expected="$simple_manifest"
		test "$result" == "$expected" || fail "Unexpected manifest '$result', expected '$expected'" && pass

		check "should generate manifest reading dir from stdin"
		result=$(echo "${_dir}" | "${snapshot}" manifest 2>&1 || echo "")
		test "$result" == "$simple_manifest" || fail "Unexpected manifest '$result', expected '$simple_manifest'" && pass

		check "should not generate manifest for explicit --id if it's not in the local cache"
		result=$("${snapshot}" manifest --id "${simple_manifest_id}" 2>&1 || echo "")
		expected="error: Manifest for snapdir ID '${simple_manifest_id}' not found in the local cache. Snapshots must be fetched or staged locally first."
		test "$result" == "$expected" || fail "Expected error '$result' to be: '$expected'" && pass

		# saving to stage so we can reference it by id
		check "should stage when generating manifest with the --stage option"
		result=$("${snapshot}" manifest --verbose --stage "${_dir}" 2>&1 || echo "")
		grep -q "Staging manifest" <<<"$result" || fail "Expected 'Staging manifest' message on '$result' verbose output" && pass
		# "${snapshot}" stage "${_dir}"

		check "should generate manifest reading id from --id"
		result=$("${snapshot}" manifest --id "${simple_manifest_id}" 2>&1 || echo "")
		test "$result" == "$simple_manifest" || fail "Unexpected manifest '$result', expected '$simple_manifest'" && pass

		check "should generate manifest reading id from stdin"
		result=$(echo "${simple_manifest_id}" | "${snapshot}" manifest 2>&1 || echo "")
		test "$result" == "$simple_manifest" || fail "Unexpected manifest '$result', expected '$simple_manifest'" && pass

		check "should --exclude files when generating manifest"
		mkdir -p "${_dir}/.ignored/"
		echo "ignored file" >"${_dir}/.ignored/ignored_file"
		result=$("${snapshot}" manifest --exclude=".ignored" "${_dir}" 2>&1 || echo "")
		rm -rf "${_dir}/.ignored/"
		expected="$simple_manifest"
		test "$result" == "$expected" || fail "Unexpected manifest '$result', expected '$expected'" && pass
		clean_files

		# --------------------------------------------------------------------------------
		# snapshot id
		# --------------------------------------------------------------------------------
		generate_files
		describe "snapshot id"
		check "should generate snapshot id"
		result=$("${snapshot}" id "${_dir}" 2>&1 || echo "")
		test "$result" == "$simple_manifest_id" || fail "Unexpected snapshot id '$result', expected '$simple_manifest_id'" && pass
		clean_files

		generate_nested_files
		describe "snapshot nested id"
		check "should generate snapshot id for nested files"
		result=$("${snapshot}" id "${_dir}" 2>&1 || echo "")
		test "$result" == "$nested_manifest_id" || fail "Unexpected nested snapshot id '$result'" && pass
		clean_files

		# --------------------------------------------------------------------------------
		# snapshot id from stdin manifest
		# --------------------------------------------------------------------------------
		clean_files
		describe "snapshot id from stdin manifest"
		check "should generate snapshot id from a manifest provided on stdin, even when no  files are present"
		result=$(echo "$simple_manifest" | "${snapshot}" id "${_dir}" 2>&1 || echo "")
		expected="$simple_manifest_id"
		test "$result" == "$expected" || fail "Unexpected snapshot id '$result'" && pass

		check "should prevent malformated stdin manifests"
		result=$(echo "foo bar" | "${snapshot}" id "${_dir}" 2>&1 || echo "")
		expected="error: Manifest or manifest ID provided through stdin is invalid."
		test "$result" == "$expected" || fail "Unexpected snapshot id '$result'" && pass

		describe "snapshot id from stdin manifest with comments"
		check "should generate snapshot id from a manifest provided on stdin, even when no  files are present"
		result=$(echo "# a comment
# another comment
$simple_manifest" | "${snapshot}" id "${_dir}" 2>&1 || echo "")
		expected="$simple_manifest_id"
		test "$result" == "$expected" || fail "Unexpected snapshot id '$result'" && pass

		# --------------------------------------------------------------------------------
		# snapshot stage
		# --------------------------------------------------------------------------------
		generate_files
		describe "snapshot stage files"
		check "should stage files in manifest"
		result=$("${snapshot}" stage --keep "${_dir}" 2>&1 || echo "")
		expected="${_SNAPDIR}_$simple_manifest_id"
		grep -q "$expected" <<<"$result" || fail "Unexpected directory name '${result}'. Expected '${expected}'" && pass
		check "should have created the staging directory"
		test -d "$result" || fail "Missing staging directory '$result'" && pass
		check "should stage file bar contents"
		[[ "bar" == $(cat "$result/.objects/$bar_path") ]] || fail "Missing link to './bar'" && pass
		check "should stage manifest"
		[[ $simple_manifest == $(cat "$result/.manifests/$simple_manifest_path") ]] || fail "Missing manifest" && pass
		rm -rf "$result"
		clean_files

		generate_files
		describe "snapshot manifest should not include staged files"
		check "should generate manifest without staged files"
		"${snapshot}" stage "${_dir}" >/dev/null
		result=$("${snapshot}" manifest "${_dir}" 2>&1 || echo "")
		expected="$simple_manifest"
		test "$result" == "$expected" || fail "Unexpected manifest '$result'" && pass
		clean_files

		generate_files
		describe "snapshot stage idempotency"
		check "should ignore .stage directories when generating manifest"
		result=$(
			"${snapshot}" stage --keep "${_dir}" >/dev/null || true
			"${snapshot}" stage --keep "${_dir}" 2>&1 || echo ""
		)
		# There should only be one directory matching "${_dir}/.${_SNAPDIR}-"*
		# shellcheck disable=SC2010
		test "$(ls -1 -a "${result}/.objects" | grep -E -c "[a-f0-9]{3}")" == "2" || fail "Unexpected number of .object directories" && pass
		rm -rf "${result}"
		clean_files

		generate_nested_files
		describe "snapshot stage nested files"
		check "should stage nested files in manifest"
		result=$("${snapshot}" stage --keep "${_dir}" 2>&1 || echo "")
		expected="${_SNAPDIR}_$nested_manifest_id"
		grep -q "$expected" <<<"$result" || fail "Unexpected directory name '$result'" && pass
		check "should have created the staging directory"
		test -d "$result" || fail "Missing staging directory got: '$result'" && pass
		check "should create a copy of the staged file foo"
		[[ "foo" == $(cat "$result/.objects/$foo_path") ]] || fail "Missing cache to './foo'" && pass
		rm -rf "${result}"
		clean_files

		generate_files
		result=$("${snapshot}" stage "${_dir}" 2>&1 || echo "")
		check "should return just the snapshot id when --keep is not specified"
		test "$result" == "$simple_manifest_id" || fail "Unexpected snapshot id '$result'" && pass
		clean_files

		# Done with snapshot internals tests, clean them all, we should not see them in the future
		rm -rf "${_dir}/.${_SNAPDIR}-"*

		# --------------------------------------------------------------------------------
		# snapshot checkout
		# --------------------------------------------------------------------------------
		describe "snapshot checkout files"
		generate_files
		"${snapshot}" stage "${_dir}" >/dev/null
		clean_files

		check "should not be able got generate an id for missing directory"
		result=$("${snapshot}" id "${_dir}" 2>&1 || echo "")
		expected="error: Base directory .* does not exist."
		grep -q "$expected" <<<"$result" || fail "Expected error '$expected' but got '$result'" && pass

		check "should checkout files from the local cache"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} "${_dir}" 2>&1 || echo "")
		[[ "$(grep -c "Checking out" <<<"$result")" == 2 ]] || fail "Expected two checkout messages, instead got '${result}'" && pass

		check "should not checkout up to date files"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} "${_dir}" 2>&1 || echo "")
		[[ "$(grep -c "is up to date" <<<"$result")" == 2 ]] || fail "Expected two up to date messages, instead got '${result}'" && pass

		check "should generate a consistent id for checkout data"
		result=$("${snapshot}" id "${_dir}" 2>&1 || echo "")
		expected="$simple_manifest_id"
		test "$result" == "$expected" || fail "Unexpected snapshot id '$result'" && pass

		check "should fail if file is modified"
		echo "not foo" >"${_dir}/foo"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} "${_dir}" 2>&1 || echo "")
		expected="File.*${_dir}/foo already exists. To override file, use the --force flag."
		grep -q "not foo" "${_dir}/foo" || fail "Expected ${_dir}/foo to contain 'not foo', instead got '$(cat "${_dir}/foo")'"
		grep -q "${expected}" <<<"${result}" || fail "Expected '${expected}', instead got '${result}'" && pass

		check "should override modified files when --force is used"
		echo "not foo" >"${_dir}/foo"
		result=$("${snapshot}" checkout --verbose --force --id=${simple_manifest_id} "${_dir}" 2>&1 || echo "")
		expected="Existing.*${_dir}/foo file overwritten via --force flag."
		grep -q "^foo$" "${_dir}/foo" || fail "Expected ${_dir}/foo to contain 'foo', instead got '$(cat "${_dir}/foo")'"
		grep -q "${expected}" <<<"${result}" || fail "Expected '${expected}', instead got '${result}'" && pass

		check "test should rollback if checkout fails"
		clean_files
		mkdir -p "${_dir}"
		echo "only-foo-should-exist" >"${_dir}/foo"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} "${_dir}" 2>&1 || echo "")
		! test -f "${_dir}/bar" || fail "Unexpected bar found on ${_dir}/. It should only contain 'foo' contents. Command output: '${result}'" && pass
		clean_files

		check "should checkout a single file with --path"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} --path=foo "${_dir}" 2>&1 || echo "")
		! test -f "${_dir}/bar" || fail "Unexpected bar found on ${_dir}/. It should only contain 'foo'. Command output: '${result}'"
		test -f "${_dir}/foo" || fail "Failed to checkout ${_dir}/foo. Command output: '${result}'" && pass
		clean_files

		check "should checkout a single directory with --path"
		clean_files
		result=$("${snapshot}" checkout --verbose --id=${nested_manifest_id} --path=a "${_dir}" 2>&1 || echo "")
		! test -f "${_dir}/b/b1/bar" || fail "Unexpected bar found on ${_dir}/b/b1/bar. It should only contain '${_dir}/a/a1/foo'. Command output: '${result}'"
		test -f "${_dir}/a/a1/foo" || fail "Failed to checkout ${_dir}/a/a1/foo. Command output: '${result}'" && pass
		clean_files

		check "should ignore leading ./ on --path"
		clean_files
		result=$("${snapshot}" checkout --verbose --id=${nested_manifest_id} --path=./a "${_dir}" 2>&1 || echo "")
		! test -f "${_dir}/b/b1/bar" || fail "Unexpected bar found on ${_dir}/b/b1/bar. It should only contain '${_dir}/a/a1/foo'. Command output: '${result}'"
		test -f "${_dir}/a/a1/foo" || fail "Failed to checkout ${_dir}/a/a1/foo. Command output: '${result}'" && pass
		clean_files

		check "should ignore trailing / on --path"
		clean_files
		result=$("${snapshot}" checkout --verbose --id=${nested_manifest_id} --path=a/ "${_dir}" 2>&1 || echo "")
		! test -f "${_dir}/b/b1/bar" || fail "Unexpected bar found on ${_dir}/b/b1/bar. It should only contain '${_dir}/a/a1/foo'. Command output: '${result}'"
		test -f "${_dir}/a/a1/foo" || fail "Failed to checkout ${_dir}/a/a1/foo. Command output: '${result}'" && pass
		clean_files

		clean_files
		check "should checkout files as links"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} --linked "${_dir}" 2>&1 || echo "")
		[[ "$(grep -c "Checking out" <<<"$result")" == 2 ]] || fail "Expected two checkout messages, instead got ${result}"
		grep -q "^foo$" "${_dir}/foo" || fail "Expected ${_dir}/foo to contain 'foo', instead got '$(cat "${_dir}/foo")'"
		if [[ "$(uname -s)" == "Darwin" ]]; then
			stat -x "${_dir}/foo" | grep -q "Links: " || fail "Expected foo to be a hardlink, instead got $(stat -x "${_dir}/foo")" && pass
		else
			stat "${_dir}/foo" | grep -q "Links: " || fail "Expected foo to be a hardlink, instead got $(stat "${_dir}/foo")" && pass
		fi

		check "should generate a consistent id for checkout data as links"
		result=$("${snapshot}" id "${_dir}" 2>&1 || echo "")
		expected="$simple_manifest_id"
		test "$result" == "$expected" || fail "Unexpected snapshot id '$result'" && pass
		clean_files

		check "should checkout to a non existing relative directory"
		result=$("${snapshot}" checkout --verbose --id=${simple_manifest_id} "snapdir-test-relative-dir" 2>&1 || echo "")
		[[ "$(grep -c "Checking out" <<<"$result")" == 2 ]] || fail "Expected two checkout messages, instead got ${result}"
		grep -q "^foo$" "snapdir-test-relative-dir/foo" || fail "Expected snapdir-test-relative-dir/foo to contain 'foo', instead got '$(cat "snapdir-test-relative-dir/foo")'" && pass
		rm -rf "snapdir-test-relative-dir"

		# --------------------------------------------------------------------------------
		# snapshot verify --id=<id> --dir=<dir>
		# --------------------------------------------------------------------------------

		check "should verify manifest"
		result=$("${snapshot}" verify --verbose --id=${simple_manifest_id} 2>&1 || echo "")
		grep -q "${simple_manifest_path}: OK" <<<"${result}" || fail "Failed to verify manifest got: '${result}'" && pass

		check "should verify objects"
		grep -q "${foo_path}: OK" <<<"${result}" || fail "Failed to verify ${foo_path} got: '${result}'" && pass

		check "should not conain double slashes in verify paths"
		! grep -q "//" <<<"${result}" || fail "Found double slashes in verify output: '${result}'" && pass

		check "should complain about a missing object"
		rm -rf "${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		result=$("${snapshot}" verify --verbose --id=${simple_manifest_id} 2>&1 || echo "")
		grep -q "${foo_path}: FAILED" <<<"${result}" || fail "Failed to verify ${foo_path} got: '${result}'" && pass

		check "should complain about a corrupted object"
		echo "corrupted" >"${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		result=$("${snapshot}" verify --verbose --id=${simple_manifest_id} 2>&1 || echo "")
		grep -q "${foo_path}: FAILED" <<<"${result}" || fail "Failed to dectect tampered ${foo_path} got: '${result}'" && pass

		check "should purge corrupted"
		rm -rf "${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		echo "corrupted" >"${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		result=$("${snapshot}" verify --verbose --purge --id=${simple_manifest_id} 2>&1 || echo "")
		grep -q "${foo_path}: FAILED" <<<"${result}" || fail "Failed to dectect tampered ${foo_path} got: '${result}'"
		! test -f "${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}" || fail "Should have purged '${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}' command output: '${result}'" && pass
		clean_files

		rm -rf "${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		echo "corrupted" >"${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		generate_files
		check "should warn about purged object"
		result=$("${snapshot}" verify --verbose --purge --id=${simple_manifest_id} 2>&1 || echo "")
		grep -q "warning: Removing corrupted objects" <<<"${result}" || fail "Failed to warn about purged object got: '${result}'" && pass
		result=$("${snapshot}" stage --verbose "${_dir}" 2>&1 || echo "")
		check "should restore tampered after a new stage"
		result=$("${snapshot}" verify --verbose --id=${simple_manifest_id} 2>&1 || echo "")
		grep -q "${foo_path}: OK" <<<"${result}" || fail "Failed to verify ${foo_path} got: '${result}'" && pass
		clean_files

		# --------------------------------------------------------------------------------
		# snapshot verify-cache
		# --------------------------------------------------------------------------------

		check "should complain about a corrupted object"
		echo "corrupted" >"${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		result=$("${snapshot}" verify-cache 2>&1 || echo "")
		grep -q "Checksum mismatch for ${foo_checksum}" <<<"${result}" || fail "Failed to dectect tampered ${foo_path} got: '${result}'" && pass

		check "should purge corrupted"
		echo "corrupted" >"${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}"
		result=$("${snapshot}" verify-cache --purge 2>&1 || echo "")
		grep -q "Checksum mismatch for ${foo_checksum}" <<<"${result}" || fail "Failed to dectect tampered ${foo_path} got: '${result}'"
		! test -f "${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}" || fail "Should have purged '${_SNAPDIR_CACHE_DIR}/.objects/${foo_path}' command output: '${result}'" && pass
		clean_files
		generate_files
		"${snapshot}" stage "${_dir}" >/dev/null
		clean_files

		# --------------------------------------------------------------------------------
		# snapshot flush-cache (cleans cache)
		# --------------------------------------------------------------------------------
		describe "snapshot flush-cache"
		clean_files
		${snapshot} checkout --force --id="${simple_manifest_id}" "${_dir}"
		${snapshot} checkout --force --id="${nested_manifest_id}" "${_dir}"
		check "should have cached files"
		find "${_SNAPDIR_CACHE_DIR}/" -type f -print 2>/dev/null | wc -l | sed 's/ //g' | grep -q "^4$" || fail "Expected 4 files in cache, instead got '$(find "${_SNAPDIR_CACHE_DIR}/" -type f -print 2>/dev/null | wc -l | sed 's/ //g')'" && pass
		check "should clear cache files"
		result="$(${snapshot} flush-cache 2>&1 || echo "")"
		! test -d "${_SNAPDIR_CACHE_DIR}/" || fail "Cache directory found after flushing cache ${_SNAPDIR_CACHE_DIR}/. Command output: '$result'" && pass
		clean_files

		# --------------------------------------------------------------------------------
		# snapshot checkout without cache
		# --------------------------------------------------------------------------------
		describe "snapshot checkout without cache"
		clean_files
		${snapshot} flush-cache
		check "should complain about missing cache"
		result="$(${snapshot} checkout --verbose --id="${simple_manifest_id}" "${_dir}" 2>&1 || echo "")"
		grep -q "Did you forget to fetch" <<<"${result}" || fail "Expected 'Did you forget to fetch...', instead got '${result}'" && pass
		clean_files

		# --------------------------------------------------------------------------------
		# snapshot version
		# --------------------------------------------------------------------------------
		describe "snapshot version"
		check "should output semver version"
		result="$("${snapshot}" version)"
		echo "${result}" | grep -q "^[0-9]*\.[0-9]*\.[0-9]*$" || fail "Expected semver version, got: ${result}" && pass
	}

	run_tests
)

_snapdir_absolute_path() {
	realpath -m "$1"
}

if [[ ${BASH_VERSION:0:1} -lt "4" ]]; then
	echo "Bash version 4.0 or higher is required. You have: ${BASH_VERSION}" >&2
	exit 1
fi

if [[ "$(uname -s)" == "Darwin" ]]; then
	# ensure at least bash 5.0 is available
	_snapdir_readlink() {
		echo "$(cd "$(dirname "$1")" || echo "" && pwd)/$(basename "$1")"
	}
else

	_snapdir_is_bussybox="$(test -h /bin/ls && echo true || echo false)"
	_snapdir_readlink() {
		readlink -f "$1"
	}
	if [[ $_snapdir_is_bussybox == "true" ]]; then
		_snapdir_absolute_path() {
			local base_dir
			base_dir="$(dirname "$1")"
			if [[ ${base_dir} == "/" ]]; then
				echo "$1"
			else
				test -d "$1" || mkdir -p "$base_dir"
				echo "$(cd "$base_dir" || echo "" && pwd)/$(basename "$1")"
			fi
		}
	fi
fi

#######
#       #    # ##### #####  #   # #####   ####  # #    # #####
#       ##   #   #   #    #  # #  #    # #    # # ##   #   #
#####   # #  #   #   #    #   #   #    # #    # # # #  #   #
#       #  # #   #   #####    #   #####  #    # # #  # #   #
#       #   ##   #   #   #    #   #      #    # # #   ##   #
####### #    #   #   #    #   #   #       ####  # #    #   #

# Run if is not sourced
if [[ ${BASH_SOURCE[0]} == "$0" ]]; then
	# Get the absolute path to ${BASH_SOURCE[0]}
	_SNAPDIR_BIN_PATH="$(_snapdir_readlink "${BASH_SOURCE[0]}")"
	_snapdir_run "${@:1}"
else
	_snapdir_export_env_defaults
fi
